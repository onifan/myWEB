[
  {
    "id": "article-1",
    "slug": "the-era-of-generative-ui-rsc-meets-ai",
    "title": {
      "zh-CN": "生成式UI时代：当React Server Components与AI相遇",
      "en": "The Era of Generative UI: Where React Server Components Meet AI"
    },
    "excerpt": {
      "zh-CN": "前端开发的下一个浪潮已经到来。这篇文章深入探讨了我如何利用React Server Components (RSC) 和Vercel AI SDK，将前端从数据展示的“信使”转变为能够动态生成内容的“创造者”。",
      "en": "The next wave of frontend development is here. This article is a deep dive into how I'm using React Server Components (RSC) and the Vercel AI SDK to transform the frontend from a data-displaying 'messenger' into a content-generating 'creator'."
    },
    "content": {
      "zh-CN": "2025年的前端开发，对我来说最激动人心的变化，莫过于UI本身开始变得“智能”。我们不再仅仅满足于从API获取JSON，然后把它渲染成列表或图表。我们正在进入一个由AI实时生成内容的**生成式UI（Generative UI）**时代。而实现这一切的关键技术，就是React Server Components (RSC)。\n\n### 为什么说RSC是游戏规则的改变者？\n\n在过去，我们的React组件都运行在浏览器里。这意味着，如果想调用一个AI模型的API，我们必须通过一个后端代理来隐藏我们的API密钥，这增加了复杂性。\n\nRSC彻底改变了这一点。它是一种完全在**服务器**上运行的React组件。看看这个例子：\n\n```tsx\n// app/components/WelcomeMessage.tsx\nimport { getUsername } from '@/lib/auth';\n\nexport async function WelcomeMessage() {\n  // 可以直接在组件里调用服务端函数\n  const username = await getUsername(); \n  return <h1>Welcome, {username}!</h1>;\n}\n```\n\n看到没？没有`useEffect`，没有客户端的数据请求。RSC可以直接访问数据库、内部服务，当然，也包括AI模型的API。这不仅安全，而且因为只把最终的HTML发送给浏览器，所以初始加载速度飞快。\n\n### RSC + AI：天作之合\n\n这种服务端执行的能力，对于集成生成式AI来说简直是绝配。我们可以在一个RSC里，安全地调用OpenAI或Google的AI模型，然后将生成的内容流式传输到客户端。\n\n为了让这个过程更简单，Vercel推出了 **AI SDK**。它提供了一系列简洁的Hooks和工具，把处理AI响应流的复杂工作都封装好了。\n\n下面是一个更实际的例子，一个可以根据用户提问实时生成答案的组件：\n\n```tsx\n// app/components/AiResponse.tsx\nimport { streamText } from 'ai';\nimport { openai } from '@ai-sdk/openai';\n\nexport async function AiResponse({ question }: { question: string }) {\n  const { textStream } = await streamText({\n    model: openai('gpt-4-turbo'),\n    prompt: `Answer the following question: ${question}`,\n  });\n\n  // 流式渲染AI的响应\n  return <div>{textStream}</div>;\n}\n```\n\n在这个组件里，我们直接调用了`streamText`函数。Vercel AI SDK会自动处理与AI模型的通信和数据流的解析，然后`{textStream}`这个神奇的变量就会把AI生成的内容一个词一个词地渲染到用户的屏幕上，带来了类似ChatGPT的打字机效果。\n\n### 未来的可能性\n\n这种模式开启了无限可能。我们可以构建：\n- **动态的产品文档**：根据用户的技能水平生成不同深度的解释。\n- **个性化的学习路径**：AI根据用户的学习进度，动态生成下一步的学习内容。\n- **智能的数据仪表盘**：用户用自然语言提问，AI直接生成数据图表和分析报告。\n\n前端开发者正在从数据的“展示者”转变为智能体验的“构建师”。拥抱RSC和AI，就是拥抱前端的未来。",
      "en": "The most exciting change in frontend development for me in 2025 is that the UI itself is starting to become 'intelligent.' We're no longer just satisfied with fetching JSON from an API and rendering it into lists or charts. We are entering the era of **Generative UI**, where content is generated by AI in real-time. And the key technology making this all possible is React Server Components (RSC).\n\n### Why are RSCs a Game-Changer?\n\nIn the past, all our React components ran in the browser. This meant that if we wanted to call an AI model's API, we had to go through a backend proxy to hide our API keys, which added complexity.\n\nRSC changes this completely. It's a type of React component that runs entirely on the **server**. Take a look at this example:\n\n```tsx\n// app/components/WelcomeMessage.tsx\nimport { getUsername } from '@/lib/auth';\n\nexport async function WelcomeMessage() {\n  // You can call server-side functions directly in the component\n  const username = await getUsername(); \n  return <h1>Welcome, {username}!</h1>;\n}\n```\n\nSee that? No `useEffect`, no client-side data fetching. RSCs can directly access databases, internal services, and, of course, AI model APIs. This is not only secure but also incredibly fast for initial loads because only the final HTML is sent to the browser.\n\n### RSC + AI: A Perfect Match\n\nThis server-side execution capability is a perfect match for integrating generative AI. We can securely call an OpenAI or Google AI model from within an RSC and then stream the generated content to the client.\n\nTo make this process even simpler, Vercel introduced the **AI SDK**. It provides a set of clean Hooks and utilities that encapsulate the complex work of handling AI response streams.\n\nHere’s a more practical example—a component that generates an answer in real-time based on a user's question:\n\n```tsx\n// app/components/AiResponse.tsx\nimport { streamText } from 'ai';\nimport { openai } from '@ai-sdk/openai';\n\nexport async function AiResponse({ question }: { question: string }) {\n  const { textStream } = await streamText({\n    model: openai('gpt-4-turbo'),\n    prompt: `Answer the following question: ${question}`,\n  });\n\n  // Stream the AI's response for rendering\n  return <div>{textStream}</div>;\n}\n```\n\nIn this component, we directly call the `streamText` function. The Vercel AI SDK automatically handles the communication with the AI model and the parsing of the data stream. Then, the magical `{textStream}` variable renders the AI-generated content word by word on the user's screen, creating a ChatGPT-like typewriter effect.\n\n### Future Possibilities\n\nThis paradigm opens up endless possibilities. We can build:\n- **Dynamic Product Documentation**: Generating explanations of varying depth based on the user's skill level.\n- **Personalized Learning Paths**: AI dynamically generates the next learning module based on the user's progress.\n- **Intelligent Data Dashboards**: Users ask questions in natural language, and AI generates data charts and analysis reports directly.\n\nFrontend developers are evolving from 'presenters' of data to 'architects' of intelligent experiences. Embracing RSC and AI is embracing the future of the frontend."
    },
    "publishDate": "2025-07-05",
    "readTime": "12 min read",
    "tags": [
      "React Server Components",
      "AI",
      "Next.js",
      "Generative UI",
      "Vercel AI SDK"
    ]
  },
  {
    "id": "article-2",
    "slug": "goodbye-api-guesswork-with-trpc",
    "title": {
      "zh-CN": "后端改个字段就炸？聊聊tRPC是怎么拯救我的全栈开发体验的",
      "en": "Backend Changed a Field and Everything Exploded? Let's Talk About How tRPC Saved My Full-Stack Dev Experience"
    },
    "excerpt": {
      "zh-CN": "我曾经因为前后端类型不同步，浪费了无数个小时去调试。直到我发现了tRPC这个宝藏，它彻底改变了我的工作流。这篇文章，就是我的“tRPC真香”现场。",
      "en": "I used to waste countless hours debugging because of out-of-sync types between my frontend and backend. Then I discovered the treasure that is tRPC, and it completely changed my workflow. This post is my 'tRPC is awesome' testimonial."
    },
    "content": {
      "zh-CN": "让我给你讲个真实的故事。上周，我正在做一个全栈项目，后端同事把一个用户API的字段 `userName` 改成了 `username`。一个很小的改动，对吧？但他忘了告诉我。结果就是，我的前端应用在生产环境上突然部分瘫痪，控制台一片红，而我花了整整一个下午才定位到这个大小写问题。那一刻，我真的觉得心累。\n\n我们明明前后端都在用TypeScript，为啥还得像两个说不同方言的人一样，靠文档和口头约定来沟通？这不科学。\n\n### 厌倦了“传话游戏”\n\n无论是用REST还是GraphQL，我们总是在玩一种“传话游戏”。后端定义一套类型，前端再根据文档复刻一套。这个过程不仅无聊，而且极其容易出错。我一直在想，难道就没有一种办法，能让我的后端类型直接“告诉”前端它长什么样吗？\n\n就在这时，我遇到了 **tRPC**。它的理念简单到让我拍案叫绝：**别搞那么多中间商，直接共享类型就完事了！**\n\n### tRPC到底爽在哪里？\n\n它没有代码生成，也不需要你去维护什么schema文件。你要做的，就是在你的Node.js后端（比如NestJS或者Hono.js）用它写你的API路由。看这个例子，是不是很眼熟？\n\n```typescript\n// server/routers/user.ts\nimport { z } from 'zod'; // 用Zod做输入验证，超好用\n// ...\n\nexport const userRouter = router({\n  getById: procedure.input(z.string()).query(({ input }) => {\n    return db.user.findUnique({ where: { id: input } });\n  }),\n  // ...\n});\n```\n\n后端就这么点事。然后，真正让我起鸡皮疙瘩的是在前端。\n\n```tsx\n// components/UserProfile.tsx\nimport { trpc } from '@/utils/trpc';\n\nfunction UserProfile({ userId }: { userId: string }) {\n  // 当你输入trpc.user.getById时，所有东西都自动补全了！\n  const { data: user, isLoading } = trpc.user.getById.useQuery(userId);\n\n  if (isLoading) return <p>加载中...</p>;\n\n  // user对象上的所有字段都有完整的类型提示\n  return <h1>你好, {user?.name}!</h1>;\n}\n```\n\n当我第一次在VS Code里敲下 `trpc.user.`，然后看到后端的 `getById` 方法带着完整的类型定义出现在提示列表里时，我真的惊了。那一刻，我感觉我的前后端项目终于被一根无形的类型之线连接了起来。如果我现在去后端把 `getById` 的输入改成数字，前端会立刻报错，根本等不到运行时。\n\n### 所以呢？\n\n所以，tRPC对我来说，不仅仅是一个工具，它是一种能带来“幸福感”的工作流。它让我把时间花在更有创造性的业务逻辑上，而不是在琐碎的类型同步和API调试上。如果你也像我一样，是个用TypeScript写全栈的开发者，并且受够了API的“猜谜游戏”，真心建议你试试tRPC。它真的能让你的开发体验好上不止一个台阶。",
      "en": "Let me tell you a true story. Last week, I was working on a full-stack project. A backend colleague changed a user API field from `userName` to `username`. A tiny change, right? But he forgot to tell me. The result? My frontend app partially crashed in production, the console was a sea of red, and I spent an entire afternoon tracking down this single capitalization issue. At that moment, I was just plain tired.\n\nWe're using TypeScript on both the frontend and backend, so why do we still have to communicate like two people speaking different dialects, relying on docs and verbal agreements? It just doesn't feel right.\n\n### Tired of the 'Telephone Game'\n\nWhether it's REST or GraphQL, we're always playing a game of 'telephone.' The backend defines a set of types, and the frontend duplicates them based on documentation. This process is not only boring but also incredibly error-prone. I kept thinking, isn't there a way for my backend types to just *tell* my frontend what they look like?\n\nAnd that's when I found **tRPC**. Its philosophy was so simple it blew my mind: **cut out the middleman and just share the types.**\n\n### So, What's So Cool About tRPC?\n\nThere's no code generation, and you don't need to maintain any schema files. All you do is write your API router on your Node.js backend (like NestJS or Hono.js). Look at this example, does it look familiar?\n\n```typescript\n// server/routers/user.ts\nimport { z } from 'zod'; // Using Zod for input validation is awesome\n// ...\n\nexport const userRouter = router({\n  getById: procedure.input(z.string()).query(({ input }) => {\n    return db.user.findUnique({ where: { id: input } });\n  }),\n  // ...\n});\n```\n\nThat's pretty much it for the backend. Then, the part that gave me goosebumps was on the frontend.\n\n```tsx\n// components/UserProfile.tsx\nimport { trpc } from '@/utils/trpc';\n\nfunction UserProfile({ userId }: { userId: string }) {\n  // When you type trpc.user.getById, everything is autocompleted!\n  const { data: user, isLoading } = trpc.user.getById.useQuery(userId);\n\n  if (isLoading) return <p>Loading...</p>;\n\n  // All fields on the user object have full type hints\n  return <h1>Hello, {user?.name}!</h1>;\n}\n```\n\nI was genuinely shocked the first time I typed `trpc.user.` in VS Code and saw my backend's `getById` method pop up in the suggestion list with its full type definition. At that moment, it felt like my frontend and backend projects were finally connected by an invisible thread of types. If I go and change the input of `getById` to a number on the backend now, my frontend will immediately complain, long before it ever becomes a runtime bug.\n\n### So, What's the Point?\n\nFor me, tRPC isn't just a tool; it's a workflow that brings 'happiness.' It lets me spend my time on creative business logic instead of tedious type syncing and API debugging. If you're a full-stack developer using TypeScript, and you're sick of the API 'guessing game' like I was, I genuinely recommend you give tRPC a try. It really can improve your development experience by more than just a little."
    },
    "publishDate": "2025-08-12",
    "readTime": "15 min read",
    "tags": [
      "tRPC",
      "TypeScript",
      "Next.js",
      "Full-Stack",
      "Developer Experience"
    ]
  }
]
